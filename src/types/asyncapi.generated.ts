// this file is generated by typescript/scripts/generate-types.ts
/* tslint:disable */
/* eslint-disable */

import { LiteralUnion } from "./helpers";

/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = T | U extends object
  ? (Without<T, U> & U) | (Without<U, T> & T)
  : T | U;
type OneOf<T extends any[]> = T extends [infer Only]
  ? Only
  : T extends [infer A, infer B, ...infer Rest]
  ? OneOf<[XOR<A, B>, ...Rest]>
  : never;

/**
 * Format: binary
 * @description Binary audio data
 */
export type AudioData = ArrayBufferLike;

/**
 * @description The encoding of the audio data
 * @default pcm_s16le
 * @enum {string}
 */
export type AudioEncoding = "pcm_s16le" | "pcm_mulaw";

/** @description Configure the threshold for how long to wait before ending an utterance. Default is 700ms. */
export type ConfigureEndUtteranceSilenceThreshold = {
  /** @description The duration threshold in milliseconds */
  end_utterance_silence_threshold: number;
};

export type FinalTranscript = RealtimeBaseTranscript & {
  /**
   * @description Describes the type of message
   * @constant
   */
  message_type: "FinalTranscript";
  /** @description Whether the text is punctuated and cased */
  punctuated: boolean;
  /** @description Whether the text is formatted, for example Dollar -> $ */
  text_formatted: boolean;
};

/** @description Manually end an utterance */
export type ForceEndUtterance = {
  /** @description A boolean value to communicate that you wish to force the end of the utterance */
  force_end_utterance: boolean;
};

/** @enum {string} */
export type MessageType =
  | "SessionBegins"
  | "PartialTranscript"
  | "FinalTranscript"
  | "SessionTerminated";

export type PartialTranscript = RealtimeBaseTranscript & {
  /**
   * @description Describes the type of message
   * @constant
   */
  message_type: "PartialTranscript";
};

export type RealtimeBaseMessage = {
  /** @description Describes the type of the message */
  message_type: MessageType;
};

export type RealtimeBaseTranscript = {
  /** @description End time of audio sample relative to session start, in milliseconds */
  audio_end: number;
  /** @description Start time of audio sample relative to session start, in milliseconds */
  audio_start: number;
  /**
   * Format: double
   * @description The confidence score of the entire transcription, between 0 and 1
   */
  confidence: number;
  /** @description The timestamp for the partial transcript */
  created: Date;
  /** @description The partial transcript for your audio */
  text: string;
  /**
   * @description An array of objects, with the information for each word in the transcription text.
   * Includes the start and end time of the word in milliseconds, the confidence score of the word, and the text, which is the word itself.
   */
  words: Word[];
};

export type RealtimeError = {
  error: string;
};

export type RealtimeMessage =
  | SessionBegins
  | PartialTranscript
  | FinalTranscript
  | SessionTerminated
  | RealtimeError;

export type RealtimeTranscript = PartialTranscript | FinalTranscript;

/** @enum {string} */
export type RealtimeTranscriptType = "PartialTranscript" | "FinalTranscript";

export type SessionBegins = RealtimeBaseMessage & {
  /** @description Timestamp when this session will expire */
  expires_at: Date;
  /**
   * @description Describes the type of the message
   * @constant
   */
  message_type: "SessionBegins";
  /**
   * Format: uuid
   * @description Unique identifier for the established session
   */
  session_id: string;
};

export type SessionTerminated = RealtimeBaseMessage & {
  /**
   * @description Describes the type of the message
   * @constant
   */
  message_type: "SessionTerminated";
};

export type TerminateSession = RealtimeBaseMessage & {
  /** @description Set to true to end your real-time session forever */
  terminate_session: boolean;
};

export type Word = {
  /**
   * Format: double
   * @description Confidence score of the word
   */
  confidence: number;
  /** @description End time of the word in milliseconds */
  end: number;
  /** @description Start time of the word in milliseconds */
  start: number;
  /** @description The word itself */
  text: string;
};
